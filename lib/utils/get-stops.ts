import distance from '@turf/distance'
import {point} from '@turf/helpers'

const MIN_SPACING_PERCENTAGE = 0.25

/**
 * Filter out autocreated stops that are very close to existing stops.
 */
function filterCloseAutocreatedStops(
  stops: CL.StopFromSegment[],
  segments: CL.ModificationSegment[],
  minSpacingPercentage = MIN_SPACING_PERCENTAGE
): CL.StopFromSegment[] {
  return stops.filter((stop, i) => {
    const nextStop = stops[i + 1]
    // Keep existing stops, the last stop, and if the next one is atuo-created.
    if (!stop.autoCreated || i === stops.length - 1 || nextStop.autoCreated) {
      return true
    }

    // Check if it's too close to the next stop, as it will always be spaced
    // away from the previous stop, since we flow stops forward.
    const delta = nextStop.distanceFromStart - stop.distanceFromStart
    const spacedCorrectlyFromNextStop =
      delta / segments[stop.index].spacing >= minSpacingPercentage

    return spacedCorrectlyFromNextStop
  })
}

/**
 * Flow stops along a route. When autogenerating stops between bona fide stops,
 * how close can an autogenerated stop come to the next non-auto-generated stop,
 * as a fraction of stop spacing? TODO Make configurable?
 */
export default function getStops(
  segments: CL.ModificationSegment[]
): CL.StopFromSegment[] {
  if (segments.length === 0) return []
  if (segments.length === 1 && segments[0].geometry.type === 'Point') {
    const coord = segments[0].geometry.coordinates
    return [
      {
        stopId: segments[0].fromStopId,
        index: 0,
        lat: coord[1],
        lng: coord[0],
        autoCreated: !segments[0].stopAtStart,
        distanceFromStart: 0
      }
    ]
  }

  const stops: CL.StopFromSegment[] = []
  const coord = segments[0].geometry.coordinates[0]
  stops.push({
    stopId: segments[0].fromStopId,
    index: 0,
    lat: coord[1],
    lng: coord[0],
    autoCreated: !segments[0].stopAtStart,
    distanceFromStart: 0
  })

  // loop over the route, making stops as we go
  let previousStopDistance = 0
  let totalDistance = 0

  for (let segIdx = 0; segIdx < segments.length; segIdx++) {
    const segment = segments[segIdx]
    // Loop over line segments within this segment accumulating distance.
    // A single transit segment can have multiple line segments, because we've
    // used a street router between endpoints
    for (let i = 1; i < segment.geometry.coordinates.length; i++) {
      // The below should always be false.
      if (segment.geometry.type !== 'LineString') {
        console.error(
          `Modification with multiple segments contains geometry with ${segment.geometry.type}`
        )
        continue
      }

      const c0 = segment.geometry.coordinates[i - 1]
      const c1 = segment.geometry.coordinates[i]
      const lineSegmentMeters = distance(point(c0), point(c1)) * 1000
      const segmentEndMeters = totalDistance + lineSegmentMeters
      const spacing = segment.spacing

      // segment.spacing = 0 means no automatic stop creation in this segment
      if (spacing > 0) {
        while (previousStopDistance + spacing < segmentEndMeters) {
          // how far into the segment do we place the stop
          let frac =
            (previousStopDistance + spacing - totalDistance) / lineSegmentMeters
          // most likely the last segment did not have automatic stop creation
          if (frac < 0) frac = 0

          const lng = c0[0] + (c1[0] - c0[0]) * frac
          const lat = c0[1] + (c1[1] - c0[1]) * frac

          // We can't just add segment.spacing because of converting negative
          // fractions to zero above. This can happen when the last segment did
          // not have automatic stop creation, or had a larger spacing.
          // TODO in the latter case, we may want to continue to apply the
          // spacing from the last line segment until we create a new stop.
          previousStopDistance = totalDistance + frac * lineSegmentMeters

          stops.push({
            stopId: undefined,
            index: segIdx,
            lat,
            lng,
            autoCreated: true,
            distanceFromStart: previousStopDistance
          })
        }
      }

      totalDistance = segmentEndMeters
    }

    if (segment.stopAtEnd) {
      const endCoord = segment.geometry.coordinates.slice(-1)[0]
      stops.push({
        stopId: segment.toStopId,
        index: segIdx + 1,
        lat: endCoord[1],
        lng: endCoord[0],
        autoCreated: false,
        distanceFromStart: totalDistance
      })

      // Restart the spacing
      previousStopDistance = totalDistance
      // Already set to the start of the next line segment.
    }
  }

  return filterCloseAutocreatedStops(stops, segments)
}
